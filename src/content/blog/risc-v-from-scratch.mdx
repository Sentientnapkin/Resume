export const frontmatter = {
  title: 'What I Learned Building a CPU from Scratch',
  date: 'December 2025',
  summary: 'Lessons from designing a RISC-V processor in Logisim. How implementing a CPU deepened my understanding of computer architecture, from instruction fetch to memory hierarchy.',
  tags: ['RISC-V', 'Computer Architecture', 'Hardware', 'CS61C'],
  readTime: '7 min read'
}

# What I Learned Building a CPU from Scratch

There's something uniquely satisfying about watching your handcrafted CPU execute its first instruction. After weeks of debugging wires and timing issues in Logisim, seeing `addi x1, x0, 5` actually store the value 5 into register x1 felt like magic.

Building a RISC-V processor from logic gates taught me more about computer architecture than any textbook could. Here's what stuck with me.

## The Datapath is Everything

Before this project, I thought of the CPU as a mysterious black box. Now I see it as an elegant pipeline of very simple operations:

1. **Fetch** the instruction from memory
2. **Decode** it to figure out what operation to perform
3. **Execute** the operation in the ALU
4. **Access memory** if needed
5. **Write back** the result to registers

```
┌─────────┐    ┌────────┐    ┌─────────┐    ┌────────┐    ┌───────────┐
│  Fetch  │ -> │ Decode │ -> │ Execute │ -> │ Memory │ -> │ Writeback │
└─────────┘    └────────┘    └─────────┘    └────────┘    └───────────┘
```

Each stage is surprisingly straightforward on its own. The complexity comes from orchestrating them together—making sure the right data gets to the right place at the right time.

## Control Logic is Where the Magic Happens

The ALU gets all the attention, but the control unit is the real brain. It's a state machine that looks at the opcode and decides:

- Which registers to read
- What operation the ALU should perform
- Whether to access memory
- Where to write the result

```python
def decode_instruction(instruction):
    opcode = instruction & 0x7F

    if opcode == 0b0110011:  # R-type
        return {
            'alu_src': 'register',
            'mem_read': False,
            'reg_write': True,
            'alu_op': get_funct(instruction)
        }
    elif opcode == 0b0000011:  # Load
        return {
            'alu_src': 'immediate',
            'mem_read': True,
            'reg_write': True,
            'alu_op': 'add'
        }
    # ... more cases
```

I spent more time debugging my control unit than any other component. One wrong signal and the whole processor produces garbage.

## Immediate Encoding is Clever (and Confusing)

RISC-V spreads immediate values across instructions in seemingly random ways. At first, this felt like poor design. Then I realized: the bit positions are chosen so that sign extension and field extraction can happen in parallel with decoding.

The immediate bits are scattered, but they always end up in the same positions in the final 32-bit value. Hardware doesn't care about human readability—it cares about gate delay.

## Memory Hierarchy Matters

My first implementation had a single memory for everything. It worked, but loading instructions and data from the same memory created bottlenecks. Separating instruction memory from data memory (Harvard architecture) was an eye-opener.

This is why real CPUs have:
- L1 instruction cache
- L1 data cache
- Separate fetch and memory stages

The abstraction of "memory" hides enormous complexity.

## Partial Loads are Tricky

Supporting `lb` (load byte) and `lh` (load halfword) alongside `lw` (load word) required careful thought. You need to:

1. Calculate the byte offset within the word
2. Extract the right bytes
3. Sign-extend or zero-extend appropriately

What seems like a simple operation requires multiplexers, shifters, and sign-extension logic.

## Debugging Hardware is Different

Software debugging has stack traces and print statements. Hardware debugging has... waveforms. Learning to read timing diagrams and trace signals through the datapath was a new skill entirely.

My debugging process:
1. Find where the output goes wrong
2. Trace backwards through the datapath
3. Check each multiplexer select signal
4. Find the control signal that's wrong
5. Fix the state machine

## The Takeaway

Building a CPU gave me a mental model I use constantly. When I write code now, I think about:

- How branches affect the pipeline
- Why cache locality matters
- What the compiler is actually generating
- Why certain operations are faster than others

The gap between software and hardware isn't as wide as it seems. Understanding both makes you better at each.

If you get the chance to build a CPU—even a simple one—take it. The insights are worth every hour of debugging.
